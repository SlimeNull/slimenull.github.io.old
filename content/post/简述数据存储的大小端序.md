---
title: '简述数据存储的大小端序'
slug: '简述数据存储的大小端序'
date: 2023-11-12 20:11:46
tags:
  - 计算机基础
description: '低位字节存储在低位地址, 则是小端序, 低位字节存储在高位地址, 则是大端序'
---



例如一个整数, 6, 它的十六进制表示为: 0x00000006


共四字节.




| 位   | 高位   | x    | x    | 低位   |
| --- | ---- | ---- | ---- | ---- |
| 值   | 0x00 | 0x00 | 0x00 | 0x06 |




例如我的存储缓冲区有四个字节:




| 地址  | 0   | 1   | 2   | 3   |
| --- | --- | --- | --- | --- |
| 值   | 0   | 0   | 0   | 0   |




如果我将这个数字存入时, 低位字节在低位地址, 则是小端序. 即,




| 地址  | 0    | 1    | 2 | 3    |
| --- | ---- | ---- | ----------------------------- | ---- |
| 值   | 0x06 | 0x00 | 0x00                          | 0x00 |




如果低位字节存储在高位地址, 则是大端序.




| 地址  | 0    | 1    | 2    | 3    |
| --- | ---- | ---- | ---- | ---- |
| 值   | 0x00 | 0x00 | 0x00 | 0x06 |




在进行网络传输时, 发送者与接收者所使用的数字解析方式必须是使用相同的端序, 否则就会产生数值错误.


虽然网络通信建议使用大端传输, 但是只要保证发送者和接收者端序一致, 就不会引发错误. 反而如果发送前都做处理, 你的逻辑会是这样, 会很麻烦, 有种脱裤子放屁的感觉:




1. BitConverter: 得到小端的字节

2. 转为大端序

3. 进行网络传输

4. 从大端序转为小端序

5. BitConverter: 得到原始数字




因为目前常用计算机(x86架构处理器)均为小端序, 并且小端序在寻址时也更加节省性能, 不需要进行额外的计算.

